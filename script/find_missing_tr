#!/usr/bin/env ruby

# Finds lines containing strings without tr(), notr() or qnotr().
# Usage:
#   find_missing_tr file, file, ... - process files
#   find_missing_tr -a              - process automatically found files
#   find_missing_tr -t              - runs integrated unit tests

# Shortcomings:
#   * does not handle C string concatenation ("foo" "bar", it's one string)
#     correctly (neither single- nor multi-line)
#   * does not handle multi-line strings (strings with a literal newline)
#     correctly, but that's ugly anyway and can be replaced with C string
#     concatenation
#   * does not know about the preprocessor, so "#define mytr tr" won't be
#     handled properly
#   * does not handle // in strings correctly
# None of these shortcomings (should) produce false negatives, so we won't miss
# any missing tr.


###########
## Utils ##
###########

def pad(length, string)
	string=string.to_s unless string.is_a?(String)
	string+(" "*(length-string.length))
end

def maxlen(strings)
	strings.map { |string| string.length }.max	
end


#######################
## String processing ##
#######################

def only_newlines(data)
	if data
		data.gsub(/[^\r\n]/, '')
	else
		""
	end
end

def to_whitespace(data)
	# Remove any whitespace except newlines
	result=only_newlines(data)

	# Return a single space if it is empty
	result=" " if result.empty?

	result
end


def preprocess(data)
	data=data.dup

	# Remove two consecutive backslashes (escaped backslash) to prevent escaped
	# backslashes escaping anything else
	data.gsub!(/\\\\/, '')

	# Remove quotes preceded by a backslash, they do not count as quotes
	data.gsub!(/\\"/, '')

	# Remove C++ style comments (//...)
	data.gsub!(/ \/\/ .* /x, '')

	# Removes C style comments (/*...*/), replacing them with a single space
	# (single-line comments) or the number of newlines contained within the
	# comment (multi-line comments). The latter has the purpose of preserving
	# the original line numbers.
	#   slash
	#   | asterisk
	#   | | any characters (non-greedy)
	#   | | |  asterisk
	#   | | |  | slash
	#   | | |  | |  multi-line
	#   | | |  | |  |
	re=/\/\*.*?\*\//m
	data.gsub!(re) { |match| to_whitespace(match) }

	# Replace any horizontal whitespace with a single space to simplify regexps
	data.gsub!(/ [ \t]+ /x, ' ')

	# Remove any whitespace at the beginning and end of lines
	data.gsub!(/ ^ \s+ /x, '')
	data.gsub!(/ \s+ $ /x, '')

	# Remove any horizontal whitespace around operators to simplify regexps
	#            any whitespace
	#            |   any of parentheses, comma, operators... as a group
	#            |   |            any whitespace
	#            |   |            |
	data.gsub!(/ [ \t]* ( [-+()<>,"] ) [ \t]* /x, '\\1')

	# Remove string concatenation
	# Note that a single gsub will not match multiple consecutive strings,
	# e.g. "ababa".gsub(/aba/, 'a') is "aba", not "a". Positive lookbehind
	# would be easier, but seems unsupported in Ruby 1.8.
	#string.gsub(/(?<= " [^"]* " ) " [^"]* " /x, '') # Positive lookbehind (without newlines)
	re=/
		(" [^"]* ") # A quoted string (group 1)
		((
			\s*        # Any whitespace (including newlines)
			" [^"]* "  # A quoted string
		)+)        # At least once, all in group 2
		/x
	data.gsub!(re) { $1+only_newlines($2) }

	data
end

def tr_missing_part(part)
	#puts "    #{part}"
	if part =~ /"/
		# This part contains a quoted string. Return true unless it is preceded by
		# one of the tr functions - tr, notr and qnotr - after a non-word character
		# (so it doesn't match fauxtr)
		if part =~ /[^\w] (tr|notr|qnotr|qnotrUtf8) \("/x
			false
		else
			true
		end
	else
		# This part does not contain a quoted string.
		false
	end
end


# This may have false positives, but it should not have false negatives (i. e.
# it should accept all lines that have a missing tr)
def tr_missing_line(line)
	# We'll be modifying the line, make a copy
	line=line.dup

	line=preprocess(line);

	# Don't consider includes (only at the beginning of the line, optionally
	# indented). A line with an include statement cannot contain any other
	# statements, so we can return false right away if we find an include
	# statement.
	return false if line =~ /^\s*#include/

	# Merge concatenated strings
	line.gsub!(/ " ([^"]*) " " ([^"]*) "   /x, '"\\1\\2"')

	# Remove qApp->translate ("context", "string") (valid tr function)
	line.gsub!(/qApp->translate \( "[^"]*" , "[^"]*" \) /x, '')

	# Remove qApp->translate ("context", "string", "comment") (valid tr function)
	line.gsub!(/qApp->translate \( "[^"]*" , "[^"]*", "[^"]*" \) /x, '')

	# Remove two-argument form of tr (valid tr function)
	line.gsub!(/tr \( "[^"]*" , "[^"]*" \) /x, '')

	# Remove 'extern "C"'
	line.gsub!(/extern "C"/x, '')

	# We could now remove all other valid tr functions, but this approach is
	# easier to read for everything that has the form foo("..."):
	# Scan the string for quote strings with what is before
	#    any number of non-quotes
	#    |    quote
	#    |    |any number of non-quotes
	#    |    ||     quote
	#    |    ||     |or
	#    |    ||     ||end of line
	#    |    ||     |||
	re=/( [^"]* " [^"]* ("|$))/x
	line.scan(re) { |match|
		# The RE contains groups, so the match is an array
		part=match[0]
		return true if tr_missing_part(part)
	}

	# No part had a missing tr, so neither does this line
	false
end


#####################
## File processing ##
#####################

def process_files(files)
	# Perform for each file
	files.each { |file|
		# Read the data from the file
		data=File.read(file)

		# Preprocess
		data=preprocess(data)

		line_number=0
		data.each_line { |line|
			line_number+=1
			if tr_missing_line(line)
				puts "#{file}:#{line_number} #{line}"
			end
		}
		
	}
end


###########
## Tests ##
###########

def test_preprocess
	tests=[
		# Single-line cases
		["foobar ();"                                  , "foobar();"],
		["foobar (); /* comment */"                    , "foobar();"], # Comment at end
		["foobar /* comment */ ();"                    , "foobar();"], # Comment in the middle
		["before /* first */ between /*second */ after", "before between after"], # Multiple comments

		# Multi-line cases
		["multi\nline", "multi\nline"], # Multi-line preserved
		["    multi    \n    line    ", "multi\nline"], # Whitespace at beginning/end of line removed
		["multi /* first */\nline /* second */", "multi\nline"], # Multiple single-line comments
		["multi /* first \n still first */ line", "multi\nline"], # Multi-line comment

		# Special cases
		["before /* first * / second */ after", "before after"], # Termination charaters with space inbetween
		["before /* first /* second */ after" , "before after"], # Opening characters in comment

		# String concatenation
		['foo="bar";'                            , nil                  ], # No string concatenation
		['foo="string" "concatenation";'         , 'foo="string";'      ], # Simple concatenation
		['foo=" string " " concatenation ";'     , 'foo="string";'      ], # Simple concatenation whitespace in strings
		['foo="string""concatenation";'          , 'foo="string";'      ], # Simple concatenation no whitespace
		['foo="multi" "string" "concatenation";' , 'foo="multi";'       ], # Multi concatenation

		# With escaped quotes
		['foo="st\\"ring" "co\\"ncatenation";'   , 'foo="string";'   ],
		['foo="st\\"ringco\\"ncatenation";'      , 'foo="stringconcatenation";'   ],

		# Multi-line string concatenation
		["foo=\"multiline\" \n \"concatenation\";", "foo=\"multiline\"\n;" ], # String continued in the next line
		["foo=\"multiline\" \n \"concatenation\"; \"after\"", "foo=\"multiline\"\n;\"after\"" ], # String continued in the next line

		# Dummy case
		["", ""]
	]

	len=maxlen(tests.map { |test| test[0].inspect })

	tests.each { |test|
		string=test[0]
		expected=test[1] || string
		actual=preprocess(string)

		if (expected==actual)
			puts "OK      - #{pad(len, string.inspect)} => #{actual.inspect}"
		else
			puts "failure - #{pad(len, string.inspect)} => expected #{expected.inspect}, got #{actual.inspect}"
		end
	}
end


def test_tr_missing_line
	test_lines=[
		# Simple cases
		['foo ();'                        , false], # No quoted text
		['a="moo"'                        , true ], # Quoted text

		# With comments
		['foo ();  // A "commented" string'     , false], # Quoted text in comment
		['a="moo"; // A comment'                , true ], # Quoted text and comment
		['a="moo"; // A "commented" string'     , true ], # Quoted text and quoted text in comment
		['a="moo", 2/3; // A "commented" string', true ], # Quoted text and quoted text in comment

		# With include
		['#include "foo.h"'               , false], # Regular include
		['    #include "foo.h"'           , false], # Indented include
		['foo (); // #include "foo.h"'    , false], # No quote, include in comment
		['a="moo"; // #include "foo.h"'   , true ], # Quoted text, #include in comment

		# With tr
		['foo=tr ("moo");'                , false],
		['foo=tr("moo");'                 , false],
		['foo=notr("moo");'               , false],
		['foo=qnotr("moo");'              , false],
		['foo=fauxtr ("moo");'            , true ],
		['foo=fauxtr("moo");'             , true ],
		['foo=t/*.*/r("moo");'            , true ], # Not tr
		['foo=faux/*.*/tr("moo");'        , false], # Not fauxtr

		# With two-argument form of tr
		['foo=tr ("moo", "disambiguation")', false],

		# With escaped quotes
		['foo=tr ("foo\\"bar")',           false], # Single escaped quote
		['foo=tr ("foo\\"bar\\"baz")',     false], # Multiple escaped quotes
		['foo=tr ("foo\\\\"bar\\\\"baz")', true],  # Now they are not escaped and actually end the string

		# With more complex tr
		['foo=qApp->translate("context","moo")'                        , false], # No whitespace
		[' foo  =  qApp  ->  translate  (  " context "  ,  " moo "  ) ', false], # Lots of whitespace
		['foo=qApp->translate("context","moo","comment")'              , false], # 3-argument form

		# extern "C"
		['extern"C"{}'        ,  false],
		['extern  "C"  {  }  ',  false],

		# Multi-line strings
		#["foo=\"moo\nbert\";" , false], # Multi-line string - not supported
		#['foo=tr(\n"bar");', false], # String on next line

		# String concatenation
		['a=" "'                        , true], # Not a string concatenation
		['foo=tr ("moo" "bert")'        , false], # String concatenation
		['foo=tr ("moo" "bert"), "bar"' , true], # Missing after string concatenation

		# With multiple strings
		['foo (tr ("moo"), tr ("bert"));' , false ],
		['foo (("moo"), tr ("bert"));'    , true  ],
		['foo (tr ("moo"), ("bert"));'    , true  ],
		['foo (tr (42), ("bert"));'       , true  ], # This tr may not be associated with that string

		['', false] # empty line
	]

	len=maxlen(test_lines.map { |test_line| test_line[0] })

	test_lines.each { |test_line|
		string=test_line[0]
		expected=test_line[1]
		actual=tr_missing_line(string.dup)

		if actual==expected
			result="OK"
		elsif expected==true
			result="false negative!"
		else
			result="failure"
		end

		puts "#{result} - #{pad(len, string)} - expected #{pad(5,expected)}, actual #{pad(5,actual)}"
	}
end


##########
## Main ##
##########

if ARGV==['-t']
	test_preprocess
	test_tr_missing_line # FIXME enable
elsif ARGV==['-a']
#	`find . -iname *.cpp`
	system("find . -iname \\*.cpp |grep -v moc_ |grep -v migrations/Migration_ |grep -v ./build/ |grep -v ./test/ |xargs #{$0}")
else
	process_files ARGV
end

