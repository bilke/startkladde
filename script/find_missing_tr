#!/usr/bin/env ruby

# Finds lines containing strings without tr(), notr() or qnotr().
# Usage:
#   find_missing_tr file, file, ... - process files
#   find_missing_tr -a              - process automatically found files
#   find_missing_tr -t              - runs integrated unit tests

# Shortcomings:
#   * does not handle C string concatenation ("foo" "bar", it's one string)
#     correctly (neither single- nor multi-line)
#   * does not handle multi-line strings (strings with a literal newline)
#     correctly, but that's ugly anyway and can be replaced with C string
#     concatenation
#   * does not know about the preprocessor, so "#define mytr tr" won't be
#     handled properly
#   * does not handle // in strings correctly
# None of these shortcomings (should) produce false negatives, so we won't miss
# any missing tr.


###########
## Utils ##
###########

def pad(length, string)
	string=string.to_s unless string.is_a?(String)
	string+(" "*(length-string.length))
end

def maxlen(strings)
	strings.map { |string| string.length }.max	
end


#######################
## String processing ##
#######################

# Removes C style comments (/*...*/), replacing them with a single space
# (single-line comments) or the number of newlines contained within the comment
# (multi-line comments). The latter has the purpose of preserving the original
# line numbers.
# This does not remove C++ comments (//...).
def remove_c_comments(string)
	#   slash
	#   | asterisk
	#   | | any characters (non-greedy)
	#   | | |  asterisk
	#   | | |  | slash
	#   | | |  | |  multi-line
	#   | | |  | |  |
	re=/\/\*.*?\*\//m
	string.gsub(re) { |match|
		replacement=match.gsub(/[^\r\n]/, '')
		replacement=" " if replacement.empty?
		replacement
	}
end

# TODO must either remove escaped quotes or make sure it is only called with
# escaped quotes removed
def remove_string_concatenation(string)
	# It is important to have the \s* in the group to reproduce line breaks
	# (when we use multi-line)
	# TODO support multi-line
	string.gsub(/ ( "[^"]*" \s* ) "[^"]*" /x, '\\1')
end

def tr_missing_part(part)
	#puts "    #{part}"
	if part =~ /"/
		# This part contains a quoted string. Return true unless it is preceded by
		# one of the tr functions - tr, notr and qnotr - after a non-word character
		# (so it doesn't match fauxtr)
		if part =~ /[^\w] (tr|notr|qnotr|qnotrUtf8) \("/x
			false
		else
			true
		end
	else
		# This part does not contain a quoted string.
		false
	end
end

# This may have false positives, but it should not have false negatives (i. e.
# it should accept all lines that have a missing tr)
def tr_missing_line(line)
	# We'll be modifying the line, make a copy
	line=line.dup

	# Remove comments (//...) - any string in a comment is not considered a
	# missing tr
	line.gsub!(/ \/\/ .* /x, '')

	# Replace any whitespace with a single space to simplify regexps
	line.gsub!(/ \s+ /, ' ')

	# Replace two consecutive backslashes (escaped backslash) with an
	# underscore to prevent escaped backslashes escaping anything else
	line.gsub!(/\\\\/, '')

	# Remove quotes preceded by a backslash, they do not count as quotes
	line.gsub!(/\\"/, '')

	# TODO remove concatenated strings

	# Remove any whitespace around operators to simplify regexps
	#            any whitespace
	#            |   any of parentheses, comma, operators... as a group
	#            |   |            any whitespace
	#            |   |            |
	line.gsub!(/ \s* ( [-+()<>,"] ) \s* /x, '\\1')

	# Don't consider includes (only at the beginning of the line, optionally
	# indented). A line with an include statement cannot contain any other
	# statements, so we can return false right away if we find an include
	# statement.
	return false if line =~ /^\s*#include/

	# Merge concatenated strings
	line.gsub!(/ " ([^"]*) " " ([^"]*) "   /x, '"\\1\\2"')

	# Remove qApp->translate ("context", "string") (valid tr function)
	line.gsub!(/qApp->translate \( "[^"]*" , "[^"]*" \) /x, '')

	# Remove qApp->translate ("context", "string", "comment") (valid tr function)
	line.gsub!(/qApp->translate \( "[^"]*" , "[^"]*", "[^"]*" \) /x, '')

	# Remove two-argument form of tr (valid tr function)
	line.gsub!(/tr \( "[^"]*" , "[^"]*" \) /x, '')

	# Remove 'extern "C"'
	line.gsub!(/extern "C"/x, '')

	# We could now remove all other valid tr functions, but this approach is
	# easier to read for everything that has the form foo("..."):
	# Scan the string for quote strings with what is before
	#    any number of non-quotes
	#    |    quote
	#    |    |any number of non-quotes
	#    |    ||     quote
	#    |    ||     |or
	#    |    ||     ||end of line
	#    |    ||     |||
	re=/( [^"]* " [^"]* ("|$))/x
	line.scan(re) { |match|
		# The RE contains groups, so the match is an array
		part=match[0]
		return true if tr_missing_part(part)
	}

	# No part had a missing tr, so neither does this line
	false
end


#####################
## File processing ##
#####################

def process_files(files)
	# Perform for each file
	files.each { |file|
		# Read the data from the file
		data=File.read(file)

		# Remove C style comments
		data=remove_c_comments(data)

		line_number=0
		data.each_line { |line|
			line_number+=1
			if tr_missing_line(line)
				puts "#{file}:#{line_number} #{line}"
			end
		}
		
	}
end


###########
## Tests ##
###########

def test_remove_c_comments
	tests=[
		# Single-line cases
		["foobar ();"                                  , "foobar ();"], # No comment
		["foobar (); /* comment */"                    , "foobar ();  "], # Comment at end
		["foobar /* comment */ ();"                    , "foobar   ();"], # Comment in the middle
		["before /* first */ between /*second */ after", "before   between   after"], # Multiple comments

		# Multi-line cases
		["multi /* first */\nline /* second */", "multi  \nline  "], # Multiple single-line comments
		["multi /* first \n still first */ line", "multi \n line"], # Multi-line comment

		# Special cases
		["before /* first * / second */ after", "before   after"], # Termination charaters with space inbetween
		["before /* first /* second */ after" , "before   after"], # Opening characters in comment

		# Dummy case
		["", ""]
	]

	len=maxlen(tests.map { |test| test[0].inspect })

	tests.each { |test|
		string=test[0]
		expected=test[1]
		actual=remove_c_comments(string)

		if (expected==actual)
			puts "OK      - #{pad(len, string.inspect)} => #{actual.inspect}"
		else
			puts "failure - #{pad(len, string.inspect)} => expected #{expected.inspect}, got #{actual.inspect}"
		end
	}
end

def test_remove_string_concatenation
	tests=[
		# Single-line cases
		['foo="bar";'                , nil                  ], # No string concatenation
		['foo="bar" "baz";'          , 'foo="bar" ;'        ], # Simple concatenation
		['foo="bar""baz";'           , 'foo="bar";'         ], # Simple concatenation no whitespace
		[' foo = " bar " " baz " ; ' , ' foo = " bar "  ; ' ], # Simple concatenation no whitespace

		# TODO test escaped quotes

		# Dummy case
		["", ""]
	]

	len=maxlen(tests.map { |test| test[0].inspect })

	tests.each { |test|
		string=test[0]
		expected=test[1]||string
		actual=remove_string_concatenation(string)

		if (expected==actual)
			puts "OK      - #{pad(len, string.inspect)} => #{actual.inspect}"
		else
			puts "failure - #{pad(len, string.inspect)} => expected #{expected.inspect}, got #{actual.inspect}"
		end
	}
end

def test_tr_missing_line
	test_lines=[
		# Simple cases
		['foo ();'                        , false], # No quoted text
		['a="moo"'                        , true ], # Quoted text

		# With comments
		['foo ();  // A "commented" string'     , false], # Quoted text in comment
		['a="moo"; // A comment'                , true ], # Quoted text and comment
		['a="moo"; // A "commented" string'     , true ], # Quoted text and quoted text in comment
		['a="moo", 2/3; // A "commented" string', true ], # Quoted text and quoted text in comment

		# With include
		['#include "foo.h"'               , false], # Regular include
		['    #include "foo.h"'           , false], # Indented include
		['foo (); // #include "foo.h"'    , false], # No quote, include in comment
		['a="moo"; // #include "foo.h"'   , true ], # Quoted text, #include in comment

		# With tr
		['foo=tr ("moo");'                , false],
		['foo=tr("moo");'                 , false],
		['foo=notr("moo");'               , false],
		['foo=qnotr("moo");'              , false],
		['foo=fauxtr ("moo");'            , true ],
		['foo=fauxtr("moo");'             , true ],

		# With two-argument form of tr
		['foo=tr ("moo", "disambiguation")', false],

		# With escaped quotes
		['foo=tr ("foo\\"bar")',           false], # Single escaped quote
		['foo=tr ("foo\\"bar\\"baz")',     false], # Multiple escaped quotes
		['foo=tr ("foo\\\\"bar\\\\"baz")', true],  # Now they are not escaped and actually end the string

		# With more complex tr
		['foo=qApp->translate("context","moo")'                        , false], # No whitespace
		[' foo  =  qApp  ->  translate  (  " context "  ,  " moo "  ) ', false], # Lots of whitespace
		['foo=qApp->translate("context","moo","comment")'              , false], # 3-argument form

		# extern "C"
		['extern"C"{}'        ,  false],
		['extern  "C"  {  }  ',  false],

		# Multi-line strings
		#["foo=\"moo\nbert\";" , false], # Multi-line string - not supported
		#['foo=tr(\n"bar");', false], # String on next line

		# String concatenation
		['a=" "'                  , true], # Not a string concatenation
		['foo=tr ("moo" "bert")' , false], # String concatenation
		#['foo=tr ("moo" \n "bert")', false], # Multi-line string concatenation - not supported

		# With multiple strings
		['foo (tr ("moo"), tr ("bert"));' , false ],
		['foo (("moo"), tr ("bert"));'    , true  ],
		['foo (tr ("moo"), ("bert"));'    , true  ],
		['foo (tr (42), ("bert"));'       , true  ], # This tr may not be associated with that string

		['', false] # empty line
	]

	len=maxlen(test_lines.map { |test_line| test_line[0] })

	test_lines.each { |test_line|
		string=test_line[0]
		expected=test_line[1]
		actual=tr_missing_line(string.dup)

		if actual==expected
			result="OK"
		elsif expected==true
			result="false negative!"
		else
			result="failure"
		end

		puts "#{result} - #{pad(len, string)} - expected #{pad(5,expected)}, actual #{pad(5,actual)}"
	}
end


##########
## Main ##
##########

if ARGV==['-t']
	test_remove_c_comments
	test_tr_missing_line
	test_remove_string_concatenation
elsif ARGV==['-a']
#	`find . -iname *.cpp`
	system("find . -iname \\*.cpp |grep -v moc_ |grep -v migrations/Migration_ |grep -v ./build/ |grep -v ./test/ |xargs #{$0}")
else
	process_files ARGV
end

