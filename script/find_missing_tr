#!/usr/bin/env ruby

###########
## Utils ##
###########

def pad(length, string)
	string=string.to_s unless string.is_a?(String)
	string+(" "*(length-string.length))
end

def maxlen(strings)
	strings.map { |string| string.length }.max	
end


#######################
## String processing ##
#######################

# Removes C style comments (/* ... */), replacing them with a single space
# (single-line comments) or the number of newlines contained within the comment
# (multi-line comments). The latter has the purpose of preserving the original
# line numbers.
# This does not remove C++ comments (// ...).
def remove_c_comments(string)
	#   slash
	#   | asterisk
	#   | | any characters (non-greedy)
	#   | | |  asterisk
	#   | | |  | slash
	#   | | |  | |  multi-line
	#   | | |  | |  |
	re=/\/\*.*?\*\//m
	string.gsub(re) { |match|
		replacement=match.gsub(/[^\r\n]/, '')
		replacement=" " if replacement.empty?
		replacement
	}
end

def tr_missing_part(part)
	# Only consider parts that contain a quote
	return false unless part =~ /"/

	# This part contains a quoted string. Return true unless it is preceded by
	# one of the tr functions - tr, notr and qnotr - after a non-word character
	# (so it doesn't match fauxtr)
	return false if part =~ /[^\w](tr|notr|qnotr)\s*\("/

	true
end

# This may have false positives, but it should not have false negatives (i. e.
# it should accept all lines that have a missing tr)
def tr_missing_line(line)
	# Remove comments
	line.gsub!(/\/\/.*/, '')

	# Don't consider includes (only at the beginning of the line, optionally indendet)
	return false if line =~ /^\s*#include/

	# Split the line into multiple parts, each containing everything up to and
	# including a maximum of one string
	# any number of non-quotes, a quote, any number of non-quotes, a quote.
	# Group everything, we're interested in the RE, not the parts delimited by it
	re=/([^"]*"[^"]*")/
	parts=line.split(re)
	parts.each { |part|
		return true if tr_missing_part(part)
	}

	false
end


#####################
## File processing ##
#####################

def process_files(files)
	# Perform for each file
	files.each { |file|
		# Read the data from the file
		data=File.read(file)

		# Remove C style comments
		data=remove_c_comments(data)

		line_number=0
		data.each_line { |line|
			line_number+=1
			if tr_missing_line(line)
				puts "#{file}:#{line_number} #{line}"
			end
		}
		
	}
end


###########
## Tests ##
###########

def test_remove_c_comments
	tests=[
		# Single-line cases
		["foobar ();"                                  , "foobar ();"], # No comment
		["foobar (); /* comment */"                    , "foobar ();  "], # Comment at end
		["foobar /* comment */ ();"                    , "foobar   ();"], # Comment in the middle
		["before /* first */ between /*second */ after", "before   between   after"], # Multiple comments

		# Multi-line cases
		["multi /* first */\nline /* second */", "multi  \nline  "], # Multiple single-line comments
		["multi /* first \n still first */ line", "multi \n line"], # Multi-line comment

		# Special cases
		["before /* first * / second */ after", "before   after"], # Termination charaters with space inbetween
		["before /* first /* second */ after" , "before   after"], # Opening characters in comment

		# Dummy case
		["", ""]
	]

	tests.each { |test|
		string=test[0]
		expected=test[1]
		actual=remove_c_comments(string)

		if (expected==actual)
			puts "OK - #{string.inspect} => #{actual.inspect}"
		else
			puts "failure - #{string.inspect}, expected #{expected.inspect}, got #{actual.inspect}"
		end
	}
end

def test_tr_missing_line
	test_lines=[
		# Simple cases
		['foo ();'                        , false], # No quoted text
		['a="moo"'                        , true ], # Quoted text

		# With comments
		['foo ();  // A "commented" string'     , false], # Quoted text in comment
		['a="moo"; // A comment'                , true ], # Quoted text and comment
		['a="moo"; // A "commented" string'     , true ], # Quoted text and quoted text in comment
		['a="moo", 2/3; // A "commented" string', true ], # Quoted text and quoted text in comment

		# With include
		['#include "foo.h"'               , false], # Regular include
		['    #include "foo.h"'           , false], # Indented include
		['foo (); // #include "foo.h"'    , false], # No quote, include in comment
		['a="moo"; // #include "foo.h"'   , true ], # Quoted text, #include in comment

		# With tr
		['foo=tr ("moo");'                , false],
		['foo=tr("moo");'                 , false],
		['foo=notr("moo");'               , false],
		['foo=qnotr("moo");'              , false],
		['foo=fauxtr ("moo");'            , true ],
		['foo=fauxtr("moo");'             , true ],

		# With multiple strings
		['foo (tr ("moo"), tr ("bert"));' , false ],
		['foo (("moo"), tr ("bert"));'    , true  ],
		['foo (tr ("moo"), ("bert"));'    , true  ],
		['foo (tr (42), ("bert"));'       , true  ], # This tr may not be associated with that string

		['', false] # empty line
	]

	len=maxlen(test_lines.map { |test_line| test_line[0] })

	test_lines.each { |test_line|
		string=test_line[0]
		expected=test_line[1]
		actual=tr_missing_line(string.dup)

		if actual==expected
			result="OK"
		elsif expected==true
			result="false negative!"
		else
			result="failure"
		end

		puts "#{pad(len, string)} - expected #{pad(5,expected)}, actual #{pad(5,actual)} - #{result}"
	}
end


##########
## Main ##
##########

if ARGV==['-t']
	test_remove_c_comments
	test_tr_missing_line
else
	process_files ARGV
end

