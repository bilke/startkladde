Format-Plugins sind Programmbibliotheken (shared libraries), die einen Flug
zusammen mit den zusätzlichen Daten (Startart, Pilot, Begleiter, Flugzeug, ggf.
Schleppflugzeug) übergeben bekommen und sie in eine Liste zur Ausgabe
umwandeln. Auf diese Weise lassen sich beliebige Ausgabeformat erzeugen, die
auch komplexere Umwandlungen machen könnnen als die Felder in einer beliebigen
Reihenfolge auszugeben.
Eine Pluginbibliothek kann mehrere Ausgabeformate bereitstellen.

Ein vollständiges Beispiel für ein Format-Plugin befindet sich in
plugins/data_format/lsv_albgau.

Um Plugins zu verwenden, müssen sie in die Konfigurationsdatei eingetragen
werden (siehe doc/config).

Die Plugins müssen folgende Funktionen bereitstellen:
  - argument_list list_formats ()
    Diese Funktion gibt eine Liste aller Datenformate zurück, die dieses Plugin
    anzeigen kann. Die Form der Liste ist eine argument_list; hierbei ist der
    Name (name) ein String, anhand dessen das Format identifiziert werden kann
    und der Wert (value) eine Bezeichnung, die dem Benutzer angezeigt wird.
	Die Namen dürfen nur Buchstaben, Ziffern, %, &, _ und - enthalten.
	Die Namen müssen nur innerhalb des Plugins eindeutig sein. 
  - void make_field_list (const string &format, list<object_field> &fields)
	Diese Funktion erstellt eine Liste von Datenfeldern, die das entsprechende
	Format beinhaltet. Hierfür kann object_field::output_field (caption, label)
	verwendet werden. caption ist hierbei die Spaltenüberschrift in der Tabelle
	und label ist ein String, anhand dessen das Datenfeld identifiziert wird.
  - void flight_to_fields (const string &format, list<object_field> &fields, const sk_flug &f, const sk_flug_data &flight_data, int &num, const string &none_text)
	Diese Funktion liest einen Flug und erstellt den entsprechenden Datensatz
	in dem gewünschten Format. Sie bekommt in fields die von der Funktion
	make_field_list erzeugte Feldliste übergeben. Mit get_label () kann der
	Label eines Feldes ausgelesen werden; der Wert wird mit set_to (string)
	gesetzt.
	Die weiteren Parameter sind:
	  - f ist der Flug.
	  - flight_data enthält die zu dem Flug gehörenden Daten wie Pilot,
		Flugzeug etc. sowie Angaben darüber, ob die jeweiligen Angaben
		überhaupt vorhanden waren und, falls ja, ob sie korrekt aus der
		Datenbank gelesen werden konnten.
	  - num ist eine laufende Nummer, die für jeden Tag auf 1 zurückgesetzt
		wird und ansonsten für jeden Flug um 1 erhöht wird. Sie gibt also die
		Nummer des Flugs an diesem Tag an. 
	  - none_text ist der String, der verwendet werden muss, wenn ein Wert leer
		oder nicht vorhanden ist. Auf keinen Fall sollte hier "", "-" oder
		ähnliches verwendet werden. none_text wird vom Aufrufer auf einen Wert
		gesetzt, der zum Ausgabeformat passt (zum Beispiel "---" für
		LaTeX-Ausgabe).
	  - error_text ist der String, der verwendet werden muss, wenn ein Feld
		fehlerhaft ist.

Wenn in dem Plugin ein Fehler auftritt, dann sollte dieser per Exception
signalisiert werden. Die folgenden Exceptions stehen zur Verfügung:
  - plugin_data_format::ex_plugin_internal_error (text)
	Ein interner Fehler, also ein Fehler in der Plugin-Bibliothek (im Gegensatz
	zu der Plugin-Klasse, die die Bibliothek verwaltet) ist aufgetreten. Alle
	anderen Exceptions sind von dieser abgeleitet.
	Die Variable fatal (kann auch mit der Funktion is_fatal (bool f=true)
	gesetzt werden) gibt an, ob der Fehler fatal ist, also, ob die Ausgabe
	abgebrochen werden muss. Voreinstellung ist fata.
  - plugin_data_format::ex_plugin_invalid_format (name)
    Ungültiges (unbekanntes) Format angefordert.

Auf keinen Fall darf auf die Standardausgabe (stdout bzw. cout) geschrieben
werden! Dies würde nahezu unweigerlich dazu führen, dass das Webinterface nicht
korrekt funktioniert.
stderr darf verwendet werden, die Ausgabe wird üblicherweise in das Fehlerlog
des Webservers geschrieben, ist also für den Benutzer nicht sichtbar. 


Technische Informationen:
Die Funktionen müssen als extern "C" deklariert werden (extern "C" void
function (...)), weil die Bibliothek dynamisch geladen wird. Zum compilieren
werden die folgenden Kommandos verwendet:
  - gcc -fPIC -c file.cpp (ergibt file.o)
  - gcc -shared -o file.so file.o (ergibt file.so)
Außerdem müssen die Include-Pfade korrekt gesetzt sein. Ein Beispiel für ein
Makefile befindet sich ebenfalls in plugins/data_format/lsv_albgau.


